## **코드가 존재하리라**

p2. 코드는 요구사항을 상세히 표현하는 수단이다. 
어느 수준에 이르면 코드의 도움 없이 요구사항을 세세하게 표현하기란 불가능하다. 추상화도 불가능하다. 정확히 명시하는 수밖에 없다.
> DSI(Domain Specific Language): 도메인 특화 언어 
특정 문제 도메인, 특정문제 표현기법, 특정 문제 해결 기법에 사용할 목적으로 만든 프로그래밍 언어나 명세 언어 




## **나쁜 코드로 치르는 대가**

p5. 나쁜 코드는 개발 속도를 크게 떨어뜨린다. 코드를 고칠 때마다 엉뚱한 곳에서 문제가 생긴다. 간단한 변경은 없다. 매번 얽히고 설킨 코드를 '해독'해서 얽히고 설킨 코드를 더한다. 시간이 지나면서 쓰레기 더미는 점점 높아지고 깊어지고 커진다. 나쁜 코드가 쌓일수록 팀 생산성은 떨어진다. 




## **깨끗한 코드란?**

p9. 논리가 간단해야 버그가 숨어들지 못한다. 의존성을 최대한 줄여야 유지보수가 쉬워진다. 
효율이 단순히 속도만을 뜻하지는 않는다. CPU 자원을 낭비하는 코드도 우아하지 못하다. 
비야네는 철저한 오류 처리도 언급한다. 세세한 사항까지 꼼꼼하게 신경 쓰라는 말이다. 프로그래머들이 대충 넘어가는 부분 중 하나가 오류 처리다. 메모리 누수, 경쟁상태, 일관성 없는 명명법이 또 다른 예다. 
마지막으로 비야네는 깨끗한 코드란 한 가지를 잘한다고 단언한다 
그래디는 비야네와 흡사한 의견을 표명하지만 가독성을 강조한다. 
깨끗한 코드는 잘 쓴 문장처럼 읽혀야 한다.

p10. 데이브는 깨끗한 코드란 다른 사람이 고치기 쉽다고 단언한다. 
데이브는 깨끗한 코드를 테스트 케이스와 연관짓는다. 
테스트 케이스가 없는 코드는 깨끗한 코드가 아니다. 아무리 가독성이 높아도, 테스트 케이스가 없으면 깨끗하지 않다.

p13. 최근 들어 나는 켄트 백이 제안한 단순한 코드 규칙으로 구현을 시작한다.
- 모든 테스트를 통과한다.
- 중복이 없다.
- 시스템 내 모든 설계 아이디어를 표현한다. 
- **클래스, 메서드, 함수 등을 최대한 줄인다.**(오홍)

p14. 내게 있어 표현력은 의미 있는 이름을 포함한다. 하지만 표현력은 이름에만 국한되지 않는다. 나는 여러 기능을 수행하는 객체나 메서드도 찾는다. 객체가 여러 기능을 수행한다면 여러 객체로 나눈다. 메서드가 여러 기능을 수행한다면 메서드 추출 리팩터리 기법을 적용해 기능을 명확히 기술하는 메서드 하나와 기능을 실제로 수행하는 메서드 여러개로 나눈다. 

p14. 중복 줄이기, 표현력 높이기, 초반부터 간단한 추상화 고려하기. 내게는 이 세가지가 깨끗한 코드를 만드는 비결이다. 
짤막한 문단 몇개로 론은 이 책 내용을 요약했다. 중복을 피하라. 한 기능만 수행하라. 제대로 표현하라. 작게 추상화하라

p15. 코드가 그 문제를 풀기위한 언어처럼 보인다면 아름다운 코드라 말한다. 

## **보이스카우트 규칙**

p19. 미국 보이스카우트가 따르는 간단한 규칙이 우리 전문가들에게도 유용하다. 
캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라.
변수 이름 하나를 개선하고 , 조금 긴 함수 하나를 분할하고 , 약간의 중복을 제거하고, 복잡한 if 문 하나를 정리하면 충분하다. 




